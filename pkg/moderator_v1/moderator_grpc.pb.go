// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: moderator.proto

package moderator_v1

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ModeratorV1Client is the client API for ModeratorV1 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ModeratorV1Client interface {
	GetProgramsToModeration(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetProgramsToModerationResponse, error)
	EnableProgramsPublic(ctx context.Context, in *EnableProgramsPublicRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	DisableProgramsPublic(ctx context.Context, in *DisableProgramsPublicRequest, opts ...grpc.CallOption) (*empty.Empty, error)
	SendProgramToModeration(ctx context.Context, in *SendProgramToModerationRequest, opts ...grpc.CallOption) (*empty.Empty, error)
}

type moderatorV1Client struct {
	cc grpc.ClientConnInterface
}

func NewModeratorV1Client(cc grpc.ClientConnInterface) ModeratorV1Client {
	return &moderatorV1Client{cc}
}

func (c *moderatorV1Client) GetProgramsToModeration(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*GetProgramsToModerationResponse, error) {
	out := new(GetProgramsToModerationResponse)
	err := c.cc.Invoke(ctx, "/moderator_v1.ModeratorV1/GetProgramsToModeration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moderatorV1Client) EnableProgramsPublic(ctx context.Context, in *EnableProgramsPublicRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/moderator_v1.ModeratorV1/EnableProgramsPublic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moderatorV1Client) DisableProgramsPublic(ctx context.Context, in *DisableProgramsPublicRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/moderator_v1.ModeratorV1/DisableProgramsPublic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moderatorV1Client) SendProgramToModeration(ctx context.Context, in *SendProgramToModerationRequest, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/moderator_v1.ModeratorV1/SendProgramToModeration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ModeratorV1Server is the server API for ModeratorV1 service.
// All implementations must embed UnimplementedModeratorV1Server
// for forward compatibility
type ModeratorV1Server interface {
	GetProgramsToModeration(context.Context, *empty.Empty) (*GetProgramsToModerationResponse, error)
	EnableProgramsPublic(context.Context, *EnableProgramsPublicRequest) (*empty.Empty, error)
	DisableProgramsPublic(context.Context, *DisableProgramsPublicRequest) (*empty.Empty, error)
	SendProgramToModeration(context.Context, *SendProgramToModerationRequest) (*empty.Empty, error)
	mustEmbedUnimplementedModeratorV1Server()
}

// UnimplementedModeratorV1Server must be embedded to have forward compatible implementations.
type UnimplementedModeratorV1Server struct {
}

func (UnimplementedModeratorV1Server) GetProgramsToModeration(context.Context, *empty.Empty) (*GetProgramsToModerationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProgramsToModeration not implemented")
}
func (UnimplementedModeratorV1Server) EnableProgramsPublic(context.Context, *EnableProgramsPublicRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableProgramsPublic not implemented")
}
func (UnimplementedModeratorV1Server) DisableProgramsPublic(context.Context, *DisableProgramsPublicRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableProgramsPublic not implemented")
}
func (UnimplementedModeratorV1Server) SendProgramToModeration(context.Context, *SendProgramToModerationRequest) (*empty.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendProgramToModeration not implemented")
}
func (UnimplementedModeratorV1Server) mustEmbedUnimplementedModeratorV1Server() {}

// UnsafeModeratorV1Server may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ModeratorV1Server will
// result in compilation errors.
type UnsafeModeratorV1Server interface {
	mustEmbedUnimplementedModeratorV1Server()
}

func RegisterModeratorV1Server(s grpc.ServiceRegistrar, srv ModeratorV1Server) {
	s.RegisterService(&ModeratorV1_ServiceDesc, srv)
}

func _ModeratorV1_GetProgramsToModeration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModeratorV1Server).GetProgramsToModeration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moderator_v1.ModeratorV1/GetProgramsToModeration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModeratorV1Server).GetProgramsToModeration(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModeratorV1_EnableProgramsPublic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableProgramsPublicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModeratorV1Server).EnableProgramsPublic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moderator_v1.ModeratorV1/EnableProgramsPublic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModeratorV1Server).EnableProgramsPublic(ctx, req.(*EnableProgramsPublicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModeratorV1_DisableProgramsPublic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableProgramsPublicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModeratorV1Server).DisableProgramsPublic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moderator_v1.ModeratorV1/DisableProgramsPublic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModeratorV1Server).DisableProgramsPublic(ctx, req.(*DisableProgramsPublicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModeratorV1_SendProgramToModeration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendProgramToModerationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModeratorV1Server).SendProgramToModeration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/moderator_v1.ModeratorV1/SendProgramToModeration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModeratorV1Server).SendProgramToModeration(ctx, req.(*SendProgramToModerationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ModeratorV1_ServiceDesc is the grpc.ServiceDesc for ModeratorV1 service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ModeratorV1_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "moderator_v1.ModeratorV1",
	HandlerType: (*ModeratorV1Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetProgramsToModeration",
			Handler:    _ModeratorV1_GetProgramsToModeration_Handler,
		},
		{
			MethodName: "EnableProgramsPublic",
			Handler:    _ModeratorV1_EnableProgramsPublic_Handler,
		},
		{
			MethodName: "DisableProgramsPublic",
			Handler:    _ModeratorV1_DisableProgramsPublic_Handler,
		},
		{
			MethodName: "SendProgramToModeration",
			Handler:    _ModeratorV1_SendProgramToModeration_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "moderator.proto",
}
